<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>S.V. Mermug Tracker</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="icon" href="/assets/favicon.ico" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f0f0f0;
    }
    .container {
      max-width: 1200px;
      margin: git ad0 auto;
      background-color: white;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }
    .info-logo-row {
      display: flex;
      flex-direction: row;
      align-items: stretch;
      gap: 20px;
      padding: 20px 20px 0 20px;
    }
    .logo-side {
      max-width: 220px;
      width: auto;
      height: auto;
      display: block;
      flex-shrink: 0;
      object-fit: contain;
    }
    .info-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      background-color: #ecf0f1;
      padding: 20px;
      border-radius: 8px;
    }
    .data-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 15px;
      margin-bottom: 20px;
    }
    .info-item {
      text-align: center;
    }
    .label {
      font-weight: bold;
      color: #34495e;
      font-size: 0.85em;
    }
    .value {
      font-size: 1.1em;
      color: #2c3e50;
      margin-top: 5px;
      font-weight: 600;
    }
    .button-row {
      display: flex;
      gap: 16px;
      margin-top: auto;
      justify-content: space-between;
    }
    .action-btn {
      flex: 1;
      padding: 12px 18px;
      border-radius: 6px;
      text-decoration: none;
      font-size: 1.1em;
      font-weight: 600;
      text-align: center;
      cursor: pointer;
      color: #fff;
    }
    .signal-btn {
      background-color: #2c3e50;
    }
    .signal-btn:hover {
      background-color: #1a232c;
    }
    .plotter-btn {
      background-color: #16a085;
    }
    .plotter-btn:hover {
      background-color: #12876d;
    }
    .wifi-note {
      font-size: 0.9em;
      font-style: italic;
      text-align: center;
      color: #7f8c8d;
      margin-top: 10px;
    }
    .map-container {
      padding: 20px;
    }
    #map {
      height: 500px;
      width: 100%;
    }
    #tideChart {
      width: 100%;
      height: 250px !important;
    }
    @media (max-width: 1200px) {
      .data-grid {
        grid-template-columns: repeat(4, 1fr);
      }
    }
    @media (max-width: 900px) {
      .data-grid {
        grid-template-columns: repeat(3, 1fr);
      }
    }
    @media (max-width: 700px) {
      .info-logo-row {
        flex-direction: column;
        gap: 10px;
        padding: 10px;
      }
      .logo-side {
        max-width: 120px;
        width: auto;
        height: auto;
        margin: 0 auto;
        object-fit: contain;
      }
      .data-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      .button-row {
        flex-direction: column;
        gap: 10px;
      }
      .info-panel {
        padding: 10px;
      }
    }
    .button-row {
      display: flex;
      flex-direction: row;
      gap: 16px;
      margin-top: 18px;
      justify-content: space-between;
    }
    .action-btn {
      flex: 1;
      padding: 12px 18px;
      border-radius: 6px;
      text-decoration: none;
      font-size: 1.1em;
      font-weight: 600;
      text-align: center;
      cursor: pointer;
      color: #fff;
    }
    .signal-btn {
      background-color: #2c3e50;
    }
    .signal-btn:hover {
      background-color: #1a232c;
    }
    .plotter-btn {
      background-color: #16a085;
    }
    .plotter-btn:hover {
      background-color: #12876d;
    }
    .wifi-note {
      font-size: 0.9em;
      font-style: italic;
      text-align: center;
      color: #7f8c8d;
      margin-top: 10px;
    }
    @media (max-width: 700px) {
      .button-row {
        flex-direction: column;
        gap: 10px;
      }
    }
    .info-logo-row {
      display: flex;
      flex-direction: row;
      align-items: stretch;
      gap: 20px;
      padding: 20px 20px 0 20px;
      width: 100%;
      box-sizing: border-box;
    }
    .logo-side {
      max-width: 220px;
      width: auto;
      height: auto;
      display: block;
      flex-shrink: 0;
      object-fit: contain;
    }
    .info-panel {
      flex: 1 1 0%;
      display: flex;
      flex-direction: column;
      background-color: #ecf0f1;
      padding: 20px;
      border-radius: 8px;
      min-width: 0;
    }
    .data-grid {
      margin-bottom: 20px;
    }
    .button-row {
      display: flex;
      flex-direction: row;
      gap: 16px;
      margin-top: auto;
      justify-content: space-between;
    }
    .action-btn {
      flex: 1;
      padding: 12px 18px;
      border-radius: 6px;
      text-decoration: none;
      font-size: 1.1em;
      font-weight: 600;
      text-align: center;
      cursor: pointer;
      color: #fff;
    }
    .signal-btn {
      background-color: #2c3e50;
    }
    .signal-btn:hover {
      background-color: #1a232c;
    }
    .plotter-btn {
      background-color: #16a085;
    }
    .plotter-btn:hover {
      background-color: #12876d;
    }
    .wifi-note {
      font-size: 0.9em;
      font-style: italic;
      text-align: center;
      color: #7f8c8d;
      margin-top: 10px;
    }
    @media (max-width: 700px) {
      .info-logo-row {
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
        padding: 10px 10px 0 10px;
      }
      .logo-side {
        max-width: 120px;
        width: auto;
        height: auto;
        margin: 0 auto;
        object-fit: contain;
      }
      .info-panel {
        padding: 10px;
      }
      .button-row {
        flex-direction: column;
        gap: 10px;
      }
    }
    .footer {
      text-align: center;
      padding: 10px;
      font-size: 0.8em;
      font-style: italic;
      color: #7f8c8d;
    }
    .footer a {
      color: #7f8c8d;
      text-decoration: none;
    }
    .footer a:hover {
      text-decoration: underline;
    }
    .ais-btn {
      background-color: #8e44ad;
    }
    .ais-btn:hover {
      background-color: #6c3483;
    }
    
    .wind-forecast-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
      margin-top: 15px;
    }
    
    .wind-forecast-item {
      background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
      border-radius: 10px;
      padding: 15px;
      text-align: center;
      color: white;
      box-shadow: 0 4px 15px rgba(116, 185, 255, 0.3);
    }
    
    .wind-time {
      font-size: 0.9em;
      font-weight: bold;
      margin-bottom: 8px;
      opacity: 0.9;
    }
    
    .wind-speed {
      font-size: 1.3em;
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .wind-direction {
      font-size: 1.1em;
      opacity: 0.9;
    }
    
    @media (max-width: 700px) {
      .wind-forecast-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }
  </style>
</head>
<body>
  <div id="updateBanner" style="text-align:center; padding:10px; font-weight:bold; background:#dff0d8; color:#2c3e50;">
  Loading data update time...
</div>
  <div class="container">
    <div class="info-logo-row">
      <img src="mermug.png" alt="Mermug Logo" class="logo-side" />
      <div class="info-panel" id="info-panel">
        <div class="data-grid" id="data-grid"></div>
        <div class="button-row">
          <a href="http://192.168.8.50:3000/admin/#/webapps" target="_blank" class="action-btn signal-btn">Open SignalK*</a>
          <a href="http://192.168.8.50:3000/@signalk/freeboard-sk" target="_blank" class="action-btn plotter-btn">Open Freeboard-SK*</a>
        </div>
        <p class="wifi-note">*Only works on Mermug WiFi</p>
        <div class="button-row" style="margin-top: 10px;">
          <a href="https://www.marinetraffic.com/en/ais/details/ships/mmsi:338543654" target="_blank" class="action-btn ais-btn">MarineTraffic</a>
          <a href="https://www.myshiptracking.com/vessels/mmsi-338543654" target="_blank" class="action-btn ais-btn">MyShipTracking</a>
        </div>
      </div>
    </div>

    <div class="map-container">
      <div id="tideHeader" style="text-align:center; padding-top: 10px; font-weight: bold; font-size: 1.1em;"></div>
      <canvas id="tideChart"></canvas>
    </div>

    <!-- WIND FORECAST SECTION -->
    <div class="map-container">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
        <div id="windHeader" style="font-weight: bold; font-size: 1.1em; text-align: center; flex: 1;">Wind Forecast at Mermug's Location</div>
        <select id="forecast-model" style="padding: 8px 12px; border-radius: 6px; border: 1px solid #ddd; background: white; font-size: 0.9em; cursor: pointer;">
          <option value="wttr">wttr.in (Global)</option>
          <option value="ecmwf">ECMWF (Global)</option>
          <option value="gfs">GFS Model (US Only)</option>
          <option value="nam">NAM Model (US Only)</option>
        </select>
      </div>
      <div class="wind-forecast-grid" id="wind-forecast-grid">
        <div class="wind-forecast-item">
          <div class="wind-time">Loading...</div>
          <div class="wind-speed">--</div>
          <div class="wind-direction">--</div>
        </div>
      </div>
    </div>

    <div class="map-container">
      <div id="map"></div>
    </div>

  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    let map, marker;
    let lat, lon; // Global variables for coordinates

    const stations = [
      { id: "9414290", name: "San Francisco", lat: 37.806, lon: -122.465 },
      { id: "9414523", name: "Alameda", lat: 37.771, lon: -122.298 },
      { id: "9414863", name: "Richmond", lat: 37.925, lon: -122.42 },
      { id: "9413450", name: "Monterey", lat: 36.605, lon: -121.888 }
    ];

    function haversine(lat1, lon1, lat2, lon2) {
      const toRad = deg => deg * Math.PI / 180;
      const R = 6371;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }
    let tideChartInstance = null;
    async function drawTideGraph(lat, lon) {
      const nearest = stations.reduce((a, b) =>
        haversine(lat, lon, a.lat, a.lon) < haversine(lat, lon, b.lat, b.lon) ? a : b
      );

      // Calculate distance in nautical miles
      const distKm = haversine(lat, lon, nearest.lat, nearest.lon);
      const distNm = (distKm / 1.852).toFixed(1);

      // Update title element above the chart
      document.getElementById("tideHeader").textContent =
        `${nearest.name} (Station #${nearest.id}) - ${distNm} NM from Mermug's Position`;


      const now = new Date();
      const startTime = new Date(now.getTime() - 6 * 60 * 60 * 1000); // 6 hours ago
      const endTime = new Date(now.getTime() + 24 * 60 * 60 * 1000); // 24 hours forward


      const begin = startTime.toISOString().split("T")[0];
      const end = endTime.toISOString().split("T")[0];

      const url = `https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?product=predictions&application=web&begin_date=${begin}&end_date=${end}&datum=MLLW&station=${nearest.id}&time_zone=gmt&units=english&interval=h&format=json`;

      try {
        const res = await fetch(url);
        const json = await res.json();
        const rawData = json.predictions;

        const data = rawData
          .map(d => ({ t: new Date(d.t), v: parseFloat(d.v) }))
          .filter(d => d.t >= startTime && d.t <= endTime);


        const labels = data.map(d => 
        new Date(d.t.getTime() - d.t.getTimezoneOffset() * 60000)
          .toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false })
      );
        const heights = data.map(d => d.v);

        const peaks = [];
        for (let i = 1; i < heights.length - 1; i++) {
          if ((heights[i] > heights[i - 1] && heights[i] > heights[i + 1]) ||
              (heights[i] < heights[i - 1] && heights[i] < heights[i + 1])) {
            peaks.push({ i, value: heights[i], time: labels[i] });
          }
        }

        // Find the current tide height (closest time to now)
        const nowUTC = new Date(Date.now() + new Date().getTimezoneOffset() * 60000);

        let currentIndex = 0;
        let minDiff = Infinity;
        data.forEach((d, i) => {
          const diff = Math.abs(d.t - nowUTC);
          if (diff < minDiff) {
            minDiff = diff;
            currentIndex = i;
          }
        });

        const canvas = document.getElementById('tideChart');
        canvas.height = 250;
        const ctx = canvas.getContext('2d');

        if (tideChartInstance) {
          tideChartInstance.destroy();
        }

        tideChartInstance = new Chart(ctx, {
          type: 'line',
          data: {
            labels,
            datasets: [
              {
                label: `Tide Height (${nearest.name})`,
                data: heights,
                borderColor: '#3498db',
                backgroundColor: 'rgba(52,152,219,0.1)',
                fill: true,
                tension: 0.4,
                pointRadius: 0
              },
              {
                label: 'Now',
                data: heights.map((v, i) => (i === currentIndex ? v : null)),
                borderColor: 'transparent',
                backgroundColor: '#e74c3c',
                pointRadius: 5,
                pointHoverRadius: 6,
                type: 'line',
                fill: false
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              tooltip: {
                mode: 'index',
                intersect: false,
                callbacks: {
                  title: ctx => `Time: ${ctx[0].label}`,
                  label: ctx => `Height: ${ctx.raw} ft`
                }
              },
              legend: { display: false },
              annotation: {
                annotations: peaks.map(p => ({
                  type: 'label',
                  xValue: labels[p.i],
                  yValue: p.value,
                  content: `${p.value.toFixed(1)} ft @ ${p.time}`,
                  backgroundColor: 'rgba(0,0,0,0.7)',
                  color: '#fff',
                  font: { size: 10 },
                  yAdjust: -20,
                  position: 'center'
                }))
              }
            },
            scales: {
              x: {
                title: {
                  display: true,
                  text: `Tides as of ${now.getMonth() + 1}/${now.getDate()}/${now.getFullYear()}`
                }
              },
              y: {
                title: { display: true, text: "Tide Height (ft)" }
              }
            }
          },
          plugins: [Chart.registry.getPlugin('annotation')]
        });
      } catch (err) {
        console.error("Tide data fetch error:", err);
      }
    }

    async function loadData() {

      function findLatestTimestamp(obj) {
        let latest = null;

        function search(o) {
          if (o && typeof o === "object") {
            for (const key in o) {
              if (key === "timestamp" && typeof o[key] === "string") {
                const t = new Date(o[key]);
                if (!isNaN(t.getTime()) && (!latest || t > latest)) {
                  latest = t;
                }
              } else if (typeof o[key] === "object") {
                search(o[key]);
              }
            }
          }
        }

        search(obj);
        return latest;
      }

      try {
        console.log('Starting to load data...');
        const res = await fetch('signalk_latest.json');
        console.log('Fetch response status:', res.status);
        const lastModified = res.headers.get('last-modified');
        const data = await res.json();
        console.log('JSON data loaded successfully');
        const nav = data.navigation || {};
        const elec = data.electrical || {};
        const env = data.environment || {};

        // Update banner with last modified time
        const banner = document.getElementById('updateBanner');

        // Try specific field first, fall back to recursive scan
        let timestampStr = data.navigation?.position?.timestamp;
        let modifiedDate = timestampStr ? new Date(timestampStr) : findLatestTimestamp(data);

        if (modifiedDate && !isNaN(modifiedDate.getTime())) {
          const now = new Date();
          const diffHours = (now - modifiedDate) / (1000 * 60 * 60);
          banner.textContent = `Data Last Updated: ${modifiedDate.toLocaleString()}`;
          if (diffHours > 3) {
            banner.style.background = "#f8d7da";
            banner.style.color = "#721c24";
          } else {
            banner.style.background = '#dff0d8';
            banner.style.color = '#2c3e50';
          }
        } else {
          banner.textContent = "Timestamp not found in JSON data";
          banner.style.background = "#f8d7da";
          banner.style.color = "#721c24";
        }

        lat = nav.position?.value?.latitude;
        lon = nav.position?.value?.longitude;

        if (lat && lon) {
          if (!map) {
            map = L.map('map').setView([lat, lon], 13);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
              attribution: '© OpenStreetMap contributors'
            }).addTo(map);
            marker = L.marker([lat, lon]).addTo(map);
          } else {
            map.setView([lat, lon]);
            marker.setLatLng([lat, lon]);
          }

          drawTideGraph(lat, lon);
          // Load wind forecast asynchronously without blocking main data load
          loadWindForecast().catch(err => console.error('Wind forecast error:', err));
        }

        // Update the data grid with vessel information
        document.getElementById('data-grid').innerHTML = `
          <div class="info-item"><div class="label">Latitude</div><div class="value">${lat?.toFixed(6) ?? 'N/A'}</div></div>
          <div class="info-item"><div class="label">Longitude</div><div class="value">${lon?.toFixed(6) ?? 'N/A'}</div></div>
          <div class="info-item"><div class="label">COG</div><div class="value">${nav.courseOverGroundTrue?.value ? (nav.courseOverGroundTrue.value * 180 / Math.PI).toFixed(0) + '°' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">SOG</div><div class="value">${nav.speedOverGround?.value ? (nav.speedOverGround.value * 1.94384).toFixed(1) + ' kts' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">STW</div><div class="value">${nav.speedThroughWater?.value ? (nav.speedThroughWater.value * 1.94384).toFixed(1) + ' kts' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Trip</div><div class="value">${nav.trip?.log?.value ? (nav.trip.log.value / 1852).toFixed(1) + ' nm' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Log</div><div class="value">${nav.log?.value ? (nav.log.value / 1852).toFixed(1) + ' nm' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Water Temp</div><div class="value">${env.water?.temperature?.value ? ((env.water.temperature.value - 273.15) * 9/5 + 32).toFixed(1) + '°F' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Wind Speed</div><div class="value">${env.wind?.speedTrue?.value ? (env.wind.speedTrue.value * 1.94384).toFixed(1) + ' kts' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Wind Dir</div><div class="value">${env.wind?.angleTrue?.value ? (env.wind.angleTrue.value * 180 / Math.PI).toFixed(0) + '°' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Battery Voltage</div><div class="value">${elec.batteries?.house?.voltage?.value?.toFixed(2) ?? 'N/A'} V</div></div>
          <div class="info-item"><div class="label">Battery Current</div><div class="value">${elec.batteries?.house?.current?.value?.toFixed(1) ?? 'N/A'} A</div></div>
          <div class="info-item"><div class="label">Battery Power</div><div class="value">${elec.batteries?.house?.power?.value?.toFixed(1) ?? 'N/A'} W</div></div>
          <div class="info-item"><div class="label">SOC</div><div class="value">${elec.batteries?.house?.capacity?.stateOfCharge?.value ? (elec.batteries.house.capacity.stateOfCharge.value * 100).toFixed(0) + '%' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Battery Time Remaining</div><div class="value">${elec.batteries?.house?.capacity?.timeRemaining?.value ? (elec.batteries.house.capacity.timeRemaining.value / 3600).toFixed(1) + ' hrs' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Anchor Distance</div><div class="value" style="color: ${nav.anchor?.currentRadius?.value && nav.anchor?.maxRadius?.value ? (nav.anchor.currentRadius.value > nav.anchor.maxRadius.value ? '#e74c3c' : '#27ae60') : '#2c3e50'}">${nav.anchor?.currentRadius?.value ? (nav.anchor.currentRadius.value * 3.28084).toFixed(1) + ' ft' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Anchor Bearing</div><div class="value">${nav.anchor?.bearingTrue?.value ? (nav.anchor.bearingTrue.value * 180 / Math.PI).toFixed(0) + '°' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Vessel Length</div><div class="value">${data.design?.length?.value?.overall ? (data.design.length.value.overall * 3.28084).toFixed(1) + ' ft' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Vessel Beam</div><div class="value">${data.design?.beam?.value ? (data.design.beam.value * 3.28084).toFixed(1) + ' ft' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Vessel Draft</div><div class="value">${data.design?.draft?.value?.maximum ? (data.design.draft.value.maximum * 3.28084).toFixed(1) + ' ft' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">MMSI</div><div class="value">338543654</div></div>
          <div class="info-item"><div class="label">USCG #</div><div class="value">1024168</div></div>
          <div class="info-item"><div class="label">Rudder Angle</div><div class="value">${data.steering?.rudderAngle?.value ? (data.steering.rudderAngle.value * 180 / Math.PI).toFixed(1) + '°' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Distance to WP</div><div class="value">${data.navigation?.courseRhumbline?.nextPoint?.distance?.value ? (data.navigation.courseRhumbline.nextPoint.distance.value / 1852).toFixed(1) + ' nm' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Course Bearing</div><div class="value">${data.navigation?.courseRhumbline?.bearingTrackTrue?.value ? (data.navigation.courseRhumbline.bearingTrackTrue.value * 180 / Math.PI).toFixed(0) + '°' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Bearing to Dest</div><div class="value">${data.navigation?.courseRhumbline?.bearingToDestinationTrue?.value ? (data.navigation.courseRhumbline.bearingToDestinationTrue.value * 180 / Math.PI).toFixed(0) + '°' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Cross Track Error</div><div class="value">${data.navigation?.courseRhumbline?.crossTrackError?.value ? data.navigation.courseRhumbline.crossTrackError.value.toFixed(1) + ' m' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Apparent Wind Angle</div><div class="value">${data.environment?.wind?.angleApparent?.value ? (data.environment.wind.angleApparent.value * 180 / Math.PI).toFixed(0) + '°' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Apparent Wind Speed</div><div class="value">${data.environment?.wind?.speedApparent?.value ? (data.environment.wind.speedApparent.value * 1.94384).toFixed(1) + ' kts' : 'N/A'}</div></div>
        `;
      } catch (err) {
        console.error("Failed to load data:", err);
        console.error("Error details:", err.message);
        const banner = document.getElementById('updateBanner');
        banner.textContent = `Error loading data: ${err.message}`;
        banner.style.background = "#f8d7da";
        banner.style.color = "#721c24";
      }
    }

    async function loadWindForecast() {
      try {
        if (!lat || !lon) {
          document.getElementById('wind-forecast-grid').innerHTML = `
            <div class="wind-forecast-item">
              <div class="wind-time">Waiting</div>
              <div class="wind-speed">For GPS</div>
              <div class="wind-direction">Position</div>
            </div>
          `;
          return;
        }
        
        const selectedModel = document.getElementById('forecast-model').value;
        let response;
        
        // Select API based on chosen model
        switch(selectedModel) {
          case 'gfs':
            // GFS model via NOAA API (US only)
            response = await fetch(`https://api.weather.gov/points/${lat},${lon}/forecast`);
            if (!response.ok) {
              throw new Error('GFS model only available for US locations');
            }
            break;
          case 'ecmwf':
            // ECMWF via OpenMeteo (free tier, global)
            response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=wind_speed_10m,wind_direction_10m&timezone=auto`);
            break;


          case 'nam':
            // NAM model via NOAA API (US only)
            response = await fetch(`https://api.weather.gov/points/${lat},${lon}/forecast/hourly`);
            if (!response.ok) {
              throw new Error('NAM model only available for US locations');
            }
            break;
          default:
            // Default to wttr.in (global)
            response = await fetch(`https://wttr.in/?format=j1&lat=${lat}&lon=${lon}`);
            break;
        }
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        let forecastHTML = '';
        const windForecastGrid = document.getElementById('wind-forecast-grid');
        
        // Parse data based on selected model
        if (selectedModel === 'wttr' && data && data.weather && data.weather[0] && data.weather[0].hourly) {
          // wttr.in format
          const timeIntervals = [3, 6, 9, 12];
          const usedIndices = new Set();
          
          timeIntervals.forEach(hours => {
            const targetTime = new Date();
            targetTime.setHours(targetTime.getHours() + hours);
            
            let closestForecast = null;
            let closestIndex = -1;
            let minDiff = Infinity;
            
            data.weather[0].hourly.forEach((forecast, index) => {
              if (usedIndices.has(index)) return;
              
              const forecastTime = new Date(forecast.time);
              const diff = Math.abs(forecastTime - targetTime);
              if (diff < minDiff) {
                minDiff = diff;
                closestForecast = forecast;
                closestIndex = index;
              }
            });
            
            if (closestForecast && closestForecast.windspeedKmph) {
              usedIndices.add(closestIndex);
              const windSpeedKmph = parseInt(closestForecast.windspeedKmph);
              const windSpeedKts = (windSpeedKmph * 0.539957).toFixed(1);
              const windDeg = parseInt(closestForecast.winddirDegree);
              const windDirection = getWindDirection(windDeg);
              
              const targetTime = new Date();
              targetTime.setHours(targetTime.getHours() + hours);
              const timeStr = targetTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
              
              const speedKts = parseFloat(windSpeedKts);
              let windColor = '';
              if (speedKts < 10) {
                windColor = 'background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);';
              } else if (speedKts >= 10 && speedKts < 15) {
                windColor = 'background: linear-gradient(135deg, #00b894 0%, #00a085 100%);';
              } else if (speedKts >= 15 && speedKts < 20) {
                windColor = 'background: linear-gradient(135deg, #fdcb6e 0%, #e17055 100%);';
              } else if (speedKts >= 20 && speedKts < 25) {
                windColor = 'background: linear-gradient(135deg, #e17055 0%, #d63031 100%);';
              } else {
                windColor = 'background: linear-gradient(135deg, #6c5ce7 0%, #a29bfe 100%);';
              }
              
              forecastHTML += `
                <div class="wind-forecast-item" style="${windColor}">
                  <div class="wind-time">+${hours}h (${timeStr})</div>
                  <div class="wind-speed">${windSpeedKts} kts</div>
                  <div class="wind-direction">${windDirection} (${windDeg}°)</div>
                </div>
              `;
            }
          });
        } else if (selectedModel === 'ecmwf' && data && data.hourly) {
          // ECMWF format
          const timeIntervals = [3, 6, 9, 12];
          const usedIndices = new Set();
          
          timeIntervals.forEach(hours => {
            const targetTime = new Date();
            targetTime.setHours(targetTime.getHours() + hours);
            
            let closestIndex = -1;
            let minDiff = Infinity;
            
            data.hourly.time.forEach((timeStr, index) => {
              if (usedIndices.has(index)) return;
              
              const forecastTime = new Date(timeStr);
              const diff = Math.abs(forecastTime - targetTime);
              if (diff < minDiff) {
                minDiff = diff;
                closestIndex = index;
              }
            });
            
            if (closestIndex >= 0) {
              usedIndices.add(closestIndex);
              const windSpeedMs = data.hourly.wind_speed_10m[closestIndex];
              const windSpeedKts = (windSpeedMs * 1.94384).toFixed(1); // m/s to knots
              const windDeg = data.hourly.wind_direction_10m[closestIndex];
              const windDirection = getWindDirection(windDeg);
              
              const targetTime = new Date();
              targetTime.setHours(targetTime.getHours() + hours);
              const timeStr = targetTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
              
              const speedKts = parseFloat(windSpeedKts);
              let windColor = '';
              if (speedKts < 10) {
                windColor = 'background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);';
              } else if (speedKts >= 10 && speedKts < 15) {
                windColor = 'background: linear-gradient(135deg, #00b894 0%, #00a085 100%);';
              } else if (speedKts >= 15 && speedKts < 20) {
                windColor = 'background: linear-gradient(135deg, #fdcb6e 0%, #e17055 100%);';
              } else if (speedKts >= 20 && speedKts < 25) {
                windColor = 'background: linear-gradient(135deg, #e17055 0%, #d63031 100%);';
              } else {
                windColor = 'background: linear-gradient(135deg, #6c5ce7 0%, #a29bfe 100%);';
              }
              
              forecastHTML += `
                <div class="wind-forecast-item" style="${windColor}">
                  <div class="wind-time">+${hours}h (${timeStr})</div>
                  <div class="wind-speed">${windSpeedKts} kts</div>
                  <div class="wind-direction">${windDirection} (${windDeg}°)</div>
                </div>
              `;
            }
          });

        } else {
          // Fallback for other models or errors
          forecastHTML = `
            <div class="wind-forecast-item">
              <div class="wind-time">Model</div>
              <div class="wind-speed">Not</div>
              <div class="wind-direction">Available</div>
            </div>
          `;
        }
        
        if (forecastHTML) {
          windForecastGrid.innerHTML = forecastHTML;
        } else {
          throw new Error('No forecast data available for this location');
        }
      } catch (error) {
        console.error('Wind forecast fetch error:', error);
        document.getElementById('wind-forecast-grid').innerHTML = `
          <div class="wind-forecast-item" style="background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);">
            <div class="wind-time">Error</div>
            <div class="wind-speed">${error.message}</div>
            <div class="wind-direction">Try another model</div>
          </div>
        `;
      }
    }
    
    function getWindDirection(degrees) {
      const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
      const index = Math.round(degrees / 22.5) % 16;
      return directions[index];
    }
    
    document.addEventListener("DOMContentLoaded", function() {
      loadData();
      
      // Add event listener for forecast model dropdown
      document.getElementById('forecast-model').addEventListener('change', function() {
        if (lat && lon) {
          loadWindForecast();
        }
      });
      
      // Update wind forecast every hour
      setInterval(() => {
        if (lat && lon) {
          loadWindForecast();
        }
      }, 60 * 60 * 1000);
    });
  </script>
  <div class="footer">
    Created by <a href="https://zackphillips.com" target="_blank">Zack Phillips</a>
  </div>
</body>
</html>
