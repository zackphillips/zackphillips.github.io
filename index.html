<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>S.V. Mermug Tracker</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="icon" href="/assets/favicon.ico" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f0f0f0;
    }
    .container {
      max-width: 100%;
      margin: 0;
      background-color: white;
      border-radius: 0;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }
    .info-logo-row {
      display: flex;
      flex-direction: row;
      align-items: stretch;
      gap: 20px;
      padding: 20px 20px 0 20px;
    }
    .logo-side {
      max-width: 220px;
      width: auto;
      height: auto;
      display: block;
      flex-shrink: 0;
      object-fit: contain;
    }
    .info-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      background-color: #ecf0f1;
      padding: 20px;
      border-radius: 8px;
    }
    .data-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 15px;
      margin-bottom: 20px;
    }
    .info-item {
      text-align: center;
    }
    .label {
      font-weight: bold;
      color: #34495e;
      font-size: 0.85em;
    }
    .value {
      font-size: 1.1em;
      color: #2c3e50;
      margin-top: 5px;
      font-weight: 600;
    }
    .button-row {
      display: flex;
      gap: 16px;
      margin-top: auto;
      justify-content: space-between;
    }
    .action-btn {
      flex: 1;
      padding: 12px 18px;
      border-radius: 6px;
      text-decoration: none;
      font-size: 1.1em;
      font-weight: 600;
      text-align: center;
      cursor: pointer;
      color: #fff;
    }
    .signal-btn {
      background-color: #2c3e50;
    }
    .signal-btn:hover {
      background-color: #1a232c;
    }
    .plotter-btn {
      background-color: #16a085;
    }
    .plotter-btn:hover {
      background-color: #12876d;
    }
    .wifi-note {
      font-size: 0.9em;
      font-style: italic;
      text-align: center;
      color: #7f8c8d;
      margin-top: 10px;
    }
    .polar-performance-grid {
      display: grid;
      grid-template-columns: 250px 1fr;
      gap: 20px;
    }
    .map-container {
      padding: 20px;
    }
    #map {
      height: 500px;
      width: 100%;
    }
    #tideChart {
      width: 100%;
      height: 250px !important;
    }
    @media (max-width: 1200px) {
      .data-grid {
        grid-template-columns: repeat(4, 1fr);
      }
    }
    @media (max-width: 900px) {
      .data-grid {
        grid-template-columns: repeat(3, 1fr);
      }
    }
    @media (max-width: 700px) {
      .info-logo-row {
        flex-direction: column;
        gap: 10px;
        padding: 10px;
      }
      .logo-side {
        max-width: 120px;
        width: auto;
        height: auto;
        margin: 0 auto;
        object-fit: contain;
      }
      .data-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      .button-row {
        flex-direction: column;
        gap: 10px;
      }
      .info-panel {
        padding: 10px;
      }
      /* Polar Performance mobile responsiveness */
      .polar-performance-grid {
        display: flex !important;
        flex-direction: column !important;
        gap: 15px !important;
      }
      .polar-chart-container {
        height: 400px !important;
      }
    }
    
    /* Additional mobile breakpoint for very small screens */
    @media (max-width: 600px) {
      .polar-performance-grid {
        display: flex !important;
        flex-direction: column !important;
        gap: 10px !important;
      }
      .polar-chart-container {
        height: 350px !important;
      }
    }
    
    /* Force mobile layout for polar performance */
    @media (max-width: 700px) {
      #polar-performance-grid {
        display: flex !important;
        flex-direction: column !important;
        gap: 15px !important;
      }
    }
    .button-row {
      display: flex;
      flex-direction: row;
      gap: 16px;
      margin-top: 18px;
      justify-content: space-between;
    }
    .action-btn {
      flex: 1;
      padding: 12px 18px;
      border-radius: 6px;
      text-decoration: none;
      font-size: 1.1em;
      font-weight: 600;
      text-align: center;
      cursor: pointer;
      color: #fff;
    }
    .signal-btn {
      background-color: #2c3e50;
    }
    .signal-btn:hover {
      background-color: #1a232c;
    }
    .plotter-btn {
      background-color: #16a085;
    }
    .plotter-btn:hover {
      background-color: #12876d;
    }
    .wifi-note {
      font-size: 0.9em;
      font-style: italic;
      text-align: center;
      color: #7f8c8d;
      margin-top: 10px;
    }
    @media (max-width: 700px) {
      .button-row {
        flex-direction: column;
        gap: 10px;
      }
    }
    .info-logo-row {
      display: flex;
      flex-direction: row;
      align-items: stretch;
      gap: 20px;
      padding: 20px 20px 0 20px;
      width: 100%;
      box-sizing: border-box;
    }
    .logo-side {
      max-width: 220px;
      width: auto;
      height: auto;
      display: block;
      flex-shrink: 0;
      object-fit: contain;
    }
    .info-panel {
      flex: 1 1 0%;
      display: flex;
      flex-direction: column;
      background-color: #ecf0f1;
      padding: 20px;
      border-radius: 8px;
      min-width: 0;
    }
    .data-grid {
      margin-bottom: 20px;
    }
    .button-row {
      display: flex;
      flex-direction: row;
      gap: 16px;
      margin-top: auto;
      justify-content: space-between;
    }
    .action-btn {
      flex: 1;
      padding: 12px 18px;
      border-radius: 6px;
      text-decoration: none;
      font-size: 1.1em;
      font-weight: 600;
      text-align: center;
      cursor: pointer;
      color: #fff;
    }
    .signal-btn {
      background-color: #2c3e50;
    }
    .signal-btn:hover {
      background-color: #1a232c;
    }
    .plotter-btn {
      background-color: #16a085;
    }
    .plotter-btn:hover {
      background-color: #12876d;
    }
    .wifi-note {
      font-size: 0.9em;
      font-style: italic;
      text-align: center;
      color: #7f8c8d;
      margin-top: 10px;
    }
    @media (max-width: 700px) {
      .info-logo-row {
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
        padding: 10px 10px 0 10px;
      }
      .logo-side {
        max-width: 120px;
        width: auto;
        height: auto;
        margin: 0 auto;
        object-fit: contain;
      }
      .info-panel {
        padding: 10px;
      }
      .button-row {
        flex-direction: column;
        gap: 10px;
      }
    }
    .footer {
      text-align: center;
      padding: 10px;
      font-size: 0.8em;
      font-style: italic;
      color: #7f8c8d;
    }
    .footer a {
      color: #7f8c8d;
      text-decoration: none;
    }
    .footer a:hover {
      text-decoration: underline;
    }
    .ais-btn {
      background-color: #8e44ad;
    }
    .ais-btn:hover {
      background-color: #6c3483;
    }
    
    .wind-forecast-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
      margin-top: 15px;
    }
    
    .wind-forecast-item {
      background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
      border-radius: 10px;
      padding: 15px;
      text-align: center;
      color: white;
      box-shadow: 0 4px 15px rgba(116, 185, 255, 0.3);
    }
    
    .wind-time {
      font-size: 0.9em;
      font-weight: bold;
      margin-bottom: 8px;
      opacity: 0.9;
    }
    
    .wind-speed {
      font-size: 1.3em;
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .wind-direction {
      font-size: 1.1em;
      opacity: 0.9;
    }
    
    @media (max-width: 700px) {
      .wind-forecast-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }
  </style>
</head>
<body>
  <div id="updateBanner" style="text-align:center; padding:10px; font-weight:bold; background:#dff0d8; color:#2c3e50;">
    <span id="dataStatus">Loading data...</span> | <span id="updateTime">--</span>
  </div>
  <div class="container">
    <div class="info-logo-row">
      <img src="mermug.png" alt="Mermug Logo" class="logo-side" />
      <div class="map-container" style="flex: 1; margin: 0;">
        <div id="mapTitle" style="font-weight: bold; font-size: 1.1em; text-align: center; margin-bottom: 10px; color: #2c3e50;">Loading location...</div>
        <div id="map"></div>
      </div>
    </div>

    <!-- LINKS -->
    <div style="margin: 20px;">
      <div class="button-row" style="justify-content: space-between; gap: 10px;">
        <a href="https://192.168.8.50:3000/admin/#/webapps" target="_blank" class="action-btn signal-btn">Open SignalK*</a>
        <a href="https://192.168.8.50:3000/@signalk/freeboard-sk" target="_blank" class="action-btn plotter-btn">Open Freeboard-SK*</a>
        <a href="https://www.marinetraffic.com/en/ais/details/ships/mmsi:338543654" target="_blank" class="action-btn ais-btn">MarineTraffic</a>
        <a href="https://www.myshiptracking.com/vessels/mmsi-338543654" target="_blank" class="action-btn ais-btn">MyShipTracking</a>
      </div>
      <p class="wifi-note">*Only works on Mermug WiFi</p>
    </div>

    <div class="info-panel" id="info-panel" style="margin: 20px;">
      <div style="font-weight: bold; font-size: 1.1em; margin-bottom: 15px; text-align: left;">Instrument Dashboard</div>
      <div class="data-grid" id="data-grid"></div>
    </div>

    <div class="info-panel" style="margin: 20px;">
      <div id="tideHeader" style="text-align:left; padding-top: 10px; font-weight: bold; font-size: 1.1em;"></div>
      <canvas id="tideChart"></canvas>
    </div>

    <!-- WIND FORECAST SECTION -->
    <div class="info-panel" style="margin: 20px;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
        <div id="windHeader" style="font-weight: bold; font-size: 1.1em; text-align: left; flex: 1;">Wind Forecast at Current Location</div>
        <select id="forecast-model" style="padding: 8px 12px; border-radius: 6px; border: 1px solid #ddd; background: white; font-size: 0.9em; cursor: pointer;">
          <option value="wttr">wttr.in</option>
          <option value="ecmwf">ECMWF</option>
        </select>
      </div>
      <div class="wind-forecast-grid" id="wind-forecast-grid">
        <div class="wind-forecast-item">
          <div class="wind-time">Loading...</div>
          <div class="wind-speed">--</div>
          <div class="wind-direction">--</div>
        </div>
      </div>
    </div>

    <!-- POLAR PERFORMANCE SECTION -->
    <div class="info-panel" style="margin: 20px;">
      <div style="font-weight: bold; font-size: 1.1em; margin-bottom: 15px; text-align: left;">Polar Performance</div>
      <div class="polar-performance-grid" id="polar-performance-grid">
        <!-- Left Column: Performance Data -->
        <div style="display: flex; flex-direction: column; gap: 15px;">
          <!-- Current Performance -->
          <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
            <div style="font-weight: bold; margin-bottom: 10px; color: #2c3e50;">Current Performance</div>
            <div id="polar-performance" style="font-size: 0.9em;">
              <div>Loading polar data...</div>
            </div>
          </div>
          <!-- VMG Analysis -->
          <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
            <div style="font-weight: bold; margin-bottom: 10px; color: #2c3e50;">VMG Analysis</div>
            <div id="vmg-analysis" style="font-size: 0.9em;">
              <div>Calculating VMG...</div>
            </div>
          </div>
        </div>
        <!-- Right Column: Polar Chart -->
        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
          <div style="font-weight: bold; margin-bottom: 10px; color: #2c3e50;">Polar Chart</div>
          <div class="polar-chart-container" style="position: relative; height: 600px; width: 100%;">
            <canvas id="polarChart"></canvas>
          </div>
        </div>
      </div>
    </div>

  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    let map, marker;
    let lat, lon; // Global variables for coordinates

    async function updateMapLocation(lat, lon) {
      try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&zoom=10&addressdetails=1`);
        const data = await response.json();
        
        let locationName = "Unknown Location";
        
        if (data.display_name) {
          // Parse the display name to get a more concise location
          const parts = data.display_name.split(', ');
          if (parts.length >= 2) {
            // Try to get city and state/country
            const city = parts[0];
            const state = parts[1];
            locationName = `${city}, ${state}`;
          } else {
            locationName = data.display_name;
          }
        }
        
        document.getElementById('mapTitle').textContent = locationName;
      } catch (error) {
        console.error('Error fetching location:', error);
        document.getElementById('mapTitle').textContent = 'Location unavailable';
      }
    }

    const stations = [
      // Southern California
      { id: "9410230", name: "La Jolla", lat: 32.867, lon: -117.257 },
      { id: "9410660", name: "Los Angeles", lat: 33.720, lon: -118.272 },
      { id: "9410840", name: "Santa Monica", lat: 34.008, lon: -118.500 },
      { id: "9411340", name: "Santa Barbara", lat: 34.403, lon: -119.692 },
      { id: "9411406", name: "Port San Luis", lat: 35.167, lon: -120.760 },
      
      // Central California
      { id: "9413450", name: "Monterey", lat: 36.605, lon: -121.888 },
      { id: "9414290", name: "San Francisco", lat: 37.806, lon: -122.465 },
      { id: "9414523", name: "Alameda", lat: 37.771, lon: -122.298 },
      { id: "9414863", name: "Richmond", lat: 37.925, lon: -122.42 },
      { id: "9415020", name: "Point Reyes", lat: 37.996, lon: -122.977 },
      
      // Northern California
      { id: "9416841", name: "Arena Cove", lat: 38.914, lon: -123.711 },
      { id: "9418767", name: "North Spit", lat: 40.767, lon: -124.217 },
      { id: "9419750", name: "Crescent City", lat: 41.745, lon: -124.183 },
      
      // Additional Bay Area stations
      { id: "9414750", name: "Redwood City", lat: 37.507, lon: -122.210 },
      { id: "9415144", name: "Point San Pablo", lat: 37.963, lon: -122.418 },
      { id: "9415209", name: "Martinez-Amorco Pier", lat: 38.034, lon: -122.127 },
      { id: "9415296", name: "Pittsburg", lat: 38.035, lon: -121.883 },
      { id: "9415402", name: "Antioch", lat: 38.020, lon: -121.806 },
      { id: "9415471", name: "Port Chicago", lat: 38.058, lon: -122.039 },
      { id: "9415618", name: "Mare Island", lat: 38.067, lon: -122.267 },
      { id: "9415683", name: "Vallejo", lat: 38.102, lon: -122.267 },
      { id: "9415804", name: "Benicia", lat: 38.047, lon: -122.158 },
      { id: "9416363", name: "Point Pinole", lat: 38.000, lon: -122.367 },
      { id: "9416580", name: "San Quentin", lat: 37.940, lon: -122.467 },
      { id: "9417420", name: "San Mateo Bridge", lat: 37.580, lon: -122.250 },
      { id: "9417645", name: "Dumbarton Bridge", lat: 37.507, lon: -122.123 },
      { id: "9417811", name: "Newark", lat: 37.515, lon: -122.078 },
      { id: "9417957", name: "Hayward", lat: 37.443, lon: -122.000 },
      { id: "9418104", name: "Fremont", lat: 37.495, lon: -122.000 },
      { id: "9418250", name: "San Leandro Marina", lat: 37.697, lon: -122.190 },
      { id: "9418393", name: "Oakland", lat: 37.810, lon: -122.314 },
      { id: "9419563", name: "San Francisco (South Beach Harbor)", lat: 37.790, lon: -122.390 },
     
    ];

    function haversine(lat1, lon1, lat2, lon2) {
      const toRad = deg => deg * Math.PI / 180;
      const R = 6371;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }
    let tideChartInstance = null;
    let polarChartInstance = null;
    let polarData = null;
    let currentEnv = null; // Global environment data
    let currentNav = null; // Global navigation data
    let signalKWebSocket = null; // WebSocket connection for real-time updates
    let isDrawingPolarChart = false; // Flag to prevent multiple simultaneous chart draws
    let lastPolarChartUpdate = 0; // Timestamp of last chart update
    async function drawTideGraph(lat, lon) {
      const nearest = stations.reduce((a, b) =>
        haversine(lat, lon, a.lat, a.lon) < haversine(lat, lon, b.lat, b.lon) ? a : b
      );

      // Calculate distance in nautical miles
      const distKm = haversine(lat, lon, nearest.lat, nearest.lon);
      const distNm = (distKm / 1.852).toFixed(1);

      // Update title element above the chart
      document.getElementById("tideHeader").textContent =
        `Tides in ${nearest.name} (Station #${nearest.id} - ${distNm} NM from Current Position)`;


      const now = new Date();
      const startTime = new Date(now.getTime() - 6 * 60 * 60 * 1000); // 6 hours ago
      const endTime = new Date(now.getTime() + 24 * 60 * 60 * 1000); // 24 hours forward


      const begin = startTime.toISOString().split("T")[0];
      const end = endTime.toISOString().split("T")[0];

      const url = `https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?product=predictions&application=web&begin_date=${begin}&end_date=${end}&datum=MLLW&station=${nearest.id}&time_zone=gmt&units=english&interval=h&format=json`;

      try {
        const res = await fetch(url);
        const json = await res.json();
        const rawData = json.predictions;

        const data = rawData
          .map(d => ({ t: new Date(d.t), v: parseFloat(d.v) }))
          .filter(d => d.t >= startTime && d.t <= endTime);


        const labels = data.map(d => 
        new Date(d.t.getTime() - d.t.getTimezoneOffset() * 60000)
          .toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false })
      );
        const heights = data.map(d => d.v);

        const peaks = [];
        for (let i = 1; i < heights.length - 1; i++) {
          if ((heights[i] > heights[i - 1] && heights[i] > heights[i + 1]) ||
              (heights[i] < heights[i - 1] && heights[i] < heights[i + 1])) {
            peaks.push({ i, value: heights[i], time: labels[i] });
          }
        }

        // Find the current tide height (closest time to now)
        const nowUTC = new Date(Date.now() + new Date().getTimezoneOffset() * 60000);

        let currentIndex = 0;
        let minDiff = Infinity;
        data.forEach((d, i) => {
          const diff = Math.abs(d.t - nowUTC);
          if (diff < minDiff) {
            minDiff = diff;
            currentIndex = i;
          }
        });

        const canvas = document.getElementById('tideChart');
        canvas.height = 250;
        const ctx = canvas.getContext('2d');

        if (tideChartInstance) {
          tideChartInstance.destroy();
        }

        tideChartInstance = new Chart(ctx, {
          type: 'line',
          data: {
            labels,
            datasets: [
              {
                label: `Tide Height (${nearest.name})`,
                data: heights,
                borderColor: '#3498db',
                backgroundColor: 'rgba(52,152,219,0.1)',
                fill: true,
                tension: 0.4,
                pointRadius: 0
              },
              {
                label: 'Now',
                data: heights.map((v, i) => (i === currentIndex ? v : null)),
                borderColor: 'transparent',
                backgroundColor: '#e74c3c',
                pointRadius: 5,
                pointHoverRadius: 6,
                type: 'line',
                fill: false
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              tooltip: {
                mode: 'index',
                intersect: false,
                callbacks: {
                  title: ctx => `Time: ${ctx[0].label}`,
                  label: ctx => `Height: ${ctx.raw} ft`
                }
              },
              legend: { display: false },
              annotation: {
                annotations: peaks.map(p => ({
                  type: 'label',
                  xValue: labels[p.i],
                  yValue: p.value,
                  content: `${p.value.toFixed(1)} ft @ ${p.time}`,
                  backgroundColor: 'rgba(0,0,0,0.7)',
                  color: '#fff',
                  font: { size: 10 },
                  yAdjust: -20,
                  position: 'center'
                }))
              }
            },
            scales: {
              x: {
                title: {
                  display: true,
                  text: `Tides as of ${now.getMonth() + 1}/${now.getDate()}/${now.getFullYear()}`
                }
              },
              y: {
                title: { display: true, text: "Tide Height (ft)" },
                min: Math.min(...heights) - 1,
                max: Math.max(...heights) + 1
              }
            }
          },
          plugins: [Chart.registry.getPlugin('annotation')]
        });
      } catch (err) {
        console.error("Tide data fetch error:", err);
      }
    }

    async function loadData() {

      function findLatestTimestamp(obj) {
        let latest = null;

        function search(o) {
          if (o && typeof o === "object") {
            for (const key in o) {
              if (key === "timestamp" && typeof o[key] === "string") {
                const t = new Date(o[key]);
                if (!isNaN(t.getTime()) && (!latest || t > latest)) {
                  latest = t;
                }
              } else if (typeof o[key] === "object") {
                search(o[key]);
              }
            }
          }
        }

        search(obj);
        return latest;
      }

      try {
        console.log('Starting to load data...');
        
        // Try SignalK API first, then local file as backup
        let res;
        let data;
        let dataSource = 'api';
        
        try {
          // SignalK REST API endpoint first with quick timeout
          const apiTimeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('API Timeout')), 250);
          });
          
          res = await Promise.race([
            fetch('https://192.168.8.50:3000/signalk/v1/api/vessels/self'),
            apiTimeoutPromise
          ]);
          if (res.ok) {
            data = await res.json();
            dataSource = 'api';
            console.log('SignalK API data loaded successfully');
          } else {
            throw new Error('SignalK API not available');
          }
        } catch (apiError) {
          console.log('SignalK API not available or timed out, trying local file');
          try {
            // Local file as backup (no timeout)
            console.log('Attempting to fetch signalk_latest.json...');
            res = await fetch('signalk_latest.json');
            console.log('Local file fetch response:', res.status, res.statusText);
            if (res.ok) {
              data = await res.json();
              dataSource = 'static';
              console.log('Local JSON file data loaded successfully');
            } else {
              throw new Error(`Local file not available: ${res.status} ${res.statusText}`);
            }
          } catch (fileError) {
            console.log('Local file fetch error:', fileError);
            console.log('Both SignalK API and local file unavailable');
            
            // Create dummy data as fallback
            console.log('Creating dummy data as fallback...');
            data = {
              navigation: {
                position: { value: { latitude: 37.806, longitude: -122.465 } },
                courseOverGroundTrue: { value: 0 },
                speedOverGround: { value: 0 },
                speedThroughWater: { value: 0 }
              },
              environment: {
                wind: {
                  speedTrue: { value: 10 },
                  angleTrue: { value: 0 }
                },
                water: { temperature: { value: 288.15 } }
              },
              electrical: {
                batteries: {
                  house: {
                    voltage: { value: 12.5 },
                    current: { value: 0 },
                    power: { value: 0 },
                    capacity: {
                      stateOfCharge: { value: 0.8 },
                      timeRemaining: { value: 36000 }
                    }
                  }
                }
              }
            };
            dataSource = 'dummy';
            console.log('Dummy data created successfully');
          }
        }
        
        console.log('Fetch response status:', res.status);
        const nav = data.navigation || {};
        const elec = data.electrical || {};
        const env = data.environment || {};
        
        // Store globally for polar performance calculations
        currentNav = nav;
        currentEnv = env;

        // Update banner with data source and timestamp
        const statusElement = document.getElementById('dataStatus');
        const timeElement = document.getElementById('updateTime');
        const banner = document.getElementById('updateBanner');

        // Set data source status
        if (dataSource === 'static') {
          statusElement.textContent = 'Static Data';
          statusElement.style.color = '#2c3e50';
        } else if (dataSource === 'api') {
          statusElement.textContent = 'ðŸŒ API Data (Remote)';
          statusElement.style.color = '#3498db';
        } else if (dataSource === 'dummy') {
          statusElement.textContent = 'âš ï¸ Demo Data';
          statusElement.style.color = '#f39c12';
        }

        // Try specific field first, fall back to recursive scan
        let timestampStr = data.navigation?.position?.timestamp;
        let modifiedDate = timestampStr ? new Date(timestampStr) : findLatestTimestamp(data);

        if (modifiedDate && !isNaN(modifiedDate.getTime())) {
          const now = new Date();
          const diffHours = (now - modifiedDate) / (1000 * 60 * 60);
          timeElement.textContent = `Last Updated: ${modifiedDate.toLocaleString()}`;
          if (diffHours > 3) {
            banner.style.background = "#f8d7da";
            banner.style.color = "#721c24";
          } else {
            banner.style.background = '#dff0d8';
            banner.style.color = '#2c3e50';
          }
        } else {
          timeElement.textContent = "Timestamp not found";
          banner.style.background = "#f8d7da";
          banner.style.color = "#721c24";
        }

        lat = nav.position?.value?.latitude;
        lon = nav.position?.value?.longitude;

        if (lat && lon) {
          if (!map) {
            map = L.map('map').setView([lat, lon], 13);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
              attribution: 'Â© OpenStreetMap contributors'
            }).addTo(map);
            marker = L.marker([lat, lon]).addTo(map);
          } else {
            map.setView([lat, lon]);
            marker.setLatLng([lat, lon]);
          }

          drawTideGraph(lat, lon);
          // Load wind forecast asynchronously without blocking main data load
          loadWindForecast().catch(err => console.error('Wind forecast error:', err));
          // Update map location title
          updateMapLocation(lat, lon).catch(err => console.error('Location fetch error:', err));
          // Update polar performance
          updatePolarPerformance();
        }

        // Update the data grid with vessel information
        document.getElementById('data-grid').innerHTML = `
          <div class="info-item"><div class="label">Latitude</div><div class="value">${lat?.toFixed(6) ?? 'N/A'}</div></div>
          <div class="info-item"><div class="label">Longitude</div><div class="value">${lon?.toFixed(6) ?? 'N/A'}</div></div>
          <div class="info-item"><div class="label">COG</div><div class="value">${nav.courseOverGroundTrue?.value ? (nav.courseOverGroundTrue.value * 180 / Math.PI).toFixed(0) + 'Â°' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">SOG</div><div class="value">${nav.speedOverGround?.value ? (nav.speedOverGround.value * 1.94384).toFixed(1) + ' kts' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">STW</div><div class="value">${nav.speedThroughWater?.value ? (nav.speedThroughWater.value * 1.94384).toFixed(1) + ' kts' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Trip</div><div class="value">${nav.trip?.log?.value ? (nav.trip.log.value / 1852).toFixed(1) + ' nm' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Log</div><div class="value">${nav.log?.value ? (nav.log.value / 1852).toFixed(1) + ' nm' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Water Temp</div><div class="value">${env.water?.temperature?.value ? ((env.water.temperature.value - 273.15) * 9/5 + 32).toFixed(1) + 'Â°F' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Wind Speed</div><div class="value">${env.wind?.speedTrue?.value ? (env.wind.speedTrue.value * 1.94384).toFixed(1) + ' kts' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Wind Dir</div><div class="value">${env.wind?.angleTrue?.value ? (env.wind.angleTrue.value * 180 / Math.PI).toFixed(0) + 'Â°' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Battery Voltage</div><div class="value">${elec.batteries?.house?.voltage?.value?.toFixed(2) ?? 'N/A'} V</div></div>
          <div class="info-item"><div class="label">Battery Current</div><div class="value">${elec.batteries?.house?.current?.value?.toFixed(1) ?? 'N/A'} A</div></div>
          <div class="info-item"><div class="label">Battery Power</div><div class="value">${elec.batteries?.house?.power?.value?.toFixed(1) ?? 'N/A'} W</div></div>
          <div class="info-item"><div class="label">SOC</div><div class="value">${elec.batteries?.house?.capacity?.stateOfCharge?.value ? (elec.batteries.house.capacity.stateOfCharge.value * 100).toFixed(0) + '%' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Battery Time Remaining</div><div class="value">${elec.batteries?.house?.capacity?.timeRemaining?.value ? (elec.batteries.house.capacity.timeRemaining.value / 3600).toFixed(1) + ' hrs' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Anchor Distance</div><div class="value" style="color: ${nav.anchor?.currentRadius?.value && nav.anchor?.maxRadius?.value ? (nav.anchor.currentRadius.value > nav.anchor.maxRadius.value ? '#e74c3c' : '#27ae60') : '#2c3e50'}">${nav.anchor?.currentRadius?.value ? (nav.anchor.currentRadius.value * 3.28084).toFixed(1) + ' ft' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Anchor Bearing</div><div class="value">${nav.anchor?.bearingTrue?.value ? (nav.anchor.bearingTrue.value * 180 / Math.PI).toFixed(0) + 'Â°' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Vessel Length</div><div class="value">${data.design?.length?.value?.overall ? (data.design.length.value.overall * 3.28084).toFixed(1) + ' ft' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Vessel Beam</div><div class="value">${data.design?.beam?.value ? (data.design.beam.value * 3.28084).toFixed(1) + ' ft' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Vessel Draft</div><div class="value">${data.design?.draft?.value?.maximum ? (data.design.draft.value.maximum * 3.28084).toFixed(1) + ' ft' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">MMSI</div><div class="value">338543654</div></div>
          <div class="info-item"><div class="label">USCG #</div><div class="value">1024168</div></div>
          <div class="info-item"><div class="label">Rudder Angle</div><div class="value">${data.steering?.rudderAngle?.value ? (data.steering.rudderAngle.value * 180 / Math.PI).toFixed(1) + 'Â°' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Distance to WP</div><div class="value">${data.navigation?.courseRhumbline?.nextPoint?.distance?.value ? (data.navigation.courseRhumbline.nextPoint.distance.value / 1852).toFixed(1) + ' nm' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Course Bearing</div><div class="value">${data.navigation?.courseRhumbline?.bearingTrackTrue?.value ? (data.navigation.courseRhumbline.bearingTrackTrue.value * 180 / Math.PI).toFixed(0) + 'Â°' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Bearing to Dest</div><div class="value">${data.navigation?.courseRhumbline?.bearingToDestinationTrue?.value ? (data.navigation.courseRhumbline.bearingToDestinationTrue.value * 180 / Math.PI).toFixed(0) + 'Â°' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Cross Track Error</div><div class="value">${data.navigation?.courseRhumbline?.crossTrackError?.value ? data.navigation.courseRhumbline.crossTrackError.value.toFixed(1) + ' m' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Apparent Wind Angle</div><div class="value">${data.environment?.wind?.angleApparent?.value ? (data.environment.wind.angleApparent.value * 180 / Math.PI).toFixed(0) + 'Â°' : 'N/A'}</div></div>
          <div class="info-item"><div class="label">Apparent Wind Speed</div><div class="value">${data.environment?.wind?.speedApparent?.value ? (data.environment.wind.speedApparent.value * 1.94384).toFixed(1) + ' kts' : 'N/A'}</div></div>
        `;
      } catch (err) {
        console.error("Failed to load data:", err);
        console.error("Error details:", err.message);
        const banner = document.getElementById('updateBanner');
        banner.textContent = `Error loading data: ${err.message}`;
        banner.style.background = "#f8d7da";
        banner.style.color = "#721c24";
      }
    }

    async function loadPolarData() {
      try {
        console.log('Loading polar data...');
        const response = await fetch('resources/polars/polars.csv');
        console.log('Polar fetch response:', response.status, response.ok);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const csvText = await response.text();
        console.log('Polar CSV loaded, length:', csvText.length);
        
        // Parse CSV data
        const lines = csvText.split('\n');
        const headers = lines[0].split(';');
        const windSpeeds = headers.slice(1).map(Number); // [4, 6, 8, 10, 12, 14, 16, 20, 24]
        console.log('Wind speeds:', windSpeeds);
        
        polarData = [];
        for (let i = 1; i < lines.length; i++) {
          const values = lines[i].split(';');
          const twa = parseFloat(values[0]); // True Wind Angle
          if (!isNaN(twa)) {
            const speeds = values.slice(1).map(v => parseFloat(v) || 0);
            polarData.push({ twa, speeds });
          }
        }
        
        console.log('Polar data loaded:', polarData.length, 'angles');
        console.log('Sample polar data:', polarData.slice(0, 3));
      } catch (error) {
        console.error('Error loading polar data:', error);
        document.getElementById('polar-performance').innerHTML = `
          <div style="color: #e74c3c;">Error loading polar data: ${error.message}</div>
        `;
      }
    }

    function getPolarSpeed(twa, tws) {
      if (!polarData) return 0;
      
      // Find closest wind speed
      const windSpeeds = [4, 6, 8, 10, 12, 14, 16, 20, 24];
      let speedIndex = 0;
      for (let i = 0; i < windSpeeds.length; i++) {
        if (tws <= windSpeeds[i]) {
          speedIndex = i;
          break;
        }
      }
      if (speedIndex === 0) speedIndex = 1;
      
      // Find closest TWA
      let closestAngle = polarData[0];
      let minDiff = Math.abs(twa - polarData[0].twa);
      
      for (const angle of polarData) {
        const diff = Math.abs(twa - angle.twa);
        if (diff < minDiff) {
          minDiff = diff;
          closestAngle = angle;
        }
      }
      
      return closestAngle.speeds[speedIndex - 1];
    }

    function calculateVMG(twa, bsp, tws) {
      // VMG = Boat Speed * cos(angle to wind)
      const angleRad = (twa * Math.PI) / 180;
      return bsp * Math.cos(angleRad);
    }

    function updatePolarPerformance() {
      console.log('updatePolarPerformance called');
      console.log('polarData available:', !!polarData);
      console.log('currentEnv available:', !!currentEnv);
      console.log('currentNav available:', !!currentNav);
      
      if (!polarData) {
        console.log('No polar data available');
        return;
      }
      
      console.log('Available wind data:', currentEnv?.wind);
      
      // Check for different wind angle data sources
      let windAngle = null;
      if (currentEnv?.wind?.angleTrue?.value) {
        windAngle = currentEnv.wind.angleTrue.value;
      } else if (currentEnv?.wind?.angleTrueWater?.value) {
        windAngle = currentEnv.wind.angleTrueWater.value;
      } else if (currentEnv?.wind?.angleApparent?.value) {
        windAngle = currentEnv.wind.angleApparent.value;
      }
      
      if (!windAngle) {
        console.log('No wind angle data available');
        return;
      }
      
      console.log('Available navigation data:', currentNav);
      
      // Check for different boat speed data sources
      let boatSpeed = null;
      if (currentNav?.speedThroughWater?.value) {
        boatSpeed = currentNav.speedThroughWater.value;
      } else if (currentNav?.speedOverGround?.value) {
        boatSpeed = currentNav.speedOverGround.value;
      }
      
      if (!boatSpeed) {
        console.log('No boat speed data available');
        return;
      }
      
      if (!currentEnv?.wind?.speedTrue?.value) {
        console.log('No wind speed data');
        return;
      }
      
      const twa = windAngle * 180 / Math.PI;
      const bsp = boatSpeed * 1.94384; // Convert to knots
      const tws = currentEnv.wind.speedTrue.value * 1.94384; // Convert to knots
      
      console.log('Calculated values:', { twa, bsp, tws });
      
      const polarSpeed = getPolarSpeed(twa, tws);
      const performancePercent = polarSpeed > 0 ? (bsp / polarSpeed * 100).toFixed(1) : 0;
      
      const vmg = calculateVMG(twa, bsp, tws);
      const polarVMG = calculateVMG(twa, polarSpeed, tws);
      
      // Update performance display
      document.getElementById('polar-performance').innerHTML = `
        <div><strong>True Wind Angle:</strong> ${twa.toFixed(1)}Â°</div>
        <div><strong>Boat Speed:</strong> ${bsp.toFixed(1)} kts</div>
        <div><strong>Polar Speed:</strong> ${polarSpeed.toFixed(1)} kts</div>
        <div><strong>Performance:</strong> <span style="color: ${performancePercent >= 95 ? '#27ae60' : performancePercent >= 85 ? '#f39c12' : '#e74c3c'}">${performancePercent}%</span></div>
      `;
      
      // Update VMG display
      document.getElementById('vmg-analysis').innerHTML = `
        <div><strong>Current VMG:</strong> ${vmg.toFixed(1)} kts</div>
        <div><strong>Polar VMG:</strong> ${polarVMG.toFixed(1)} kts</div>
        <div><strong>VMG %:</strong> <span style="color: ${vmg >= polarVMG * 0.95 ? '#27ae60' : vmg >= polarVMG * 0.85 ? '#f39c12' : '#e74c3c'}">${polarVMG > 0 ? (vmg / polarVMG * 100).toFixed(1) : 0}%</span></div>
      `;
      
      // Update polar chart
      console.log('Drawing polar chart with:', { twa, bsp, tws });
      drawPolarChart(twa, bsp, tws);
    }

    function drawPolarChart(currentTWA, currentSpeed, currentTWS) {
      const timestamp = new Date().toISOString();
      console.log(`[${timestamp}] drawPolarChart called with:`, { currentTWA, currentSpeed, currentTWS });
      
      const now = Date.now();
      if (isDrawingPolarChart) {
        console.log('Chart drawing already in progress, skipping...');
        return;
      }
      
      // Throttle chart updates to prevent too frequent redraws
      if (now - lastPolarChartUpdate < 2000) { // 2 second throttle
        console.log('Chart update throttled, last update was', now - lastPolarChartUpdate, 'ms ago');
        return;
      }
      
      if (!polarData) return;
      
      isDrawingPolarChart = true;
      lastPolarChartUpdate = now;
      
      const canvas = document.getElementById('polarChart');
      const ctx = canvas.getContext('2d');
      
      // Ensure previous chart is properly destroyed
      if (polarChartInstance) {
        console.log('Destroying previous chart instance');
        polarChartInstance.destroy();
        polarChartInstance = null;
      } else {
        console.log('No previous chart instance to destroy');
      }
      
      // Clear the canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      console.log('Canvas cleared');
      
      // Determine which side to show based on boat course
      let focusSide = 'starboard'; // default
      if (currentNav?.courseOverGroundTrue?.value) {
        const boatCourse = currentNav.courseOverGroundTrue.value * 180 / Math.PI;
        const windDirection = currentEnv?.wind?.angleTrueWater?.value * 180 / Math.PI;
        
        // Calculate relative angle to determine tack
        let relativeAngle = boatCourse - windDirection;
        if (relativeAngle > 180) relativeAngle -= 360;
        if (relativeAngle < -180) relativeAngle += 360;
        
        // Positive = starboard tack, negative = port tack
        focusSide = relativeAngle > 0 ? 'starboard' : 'port';
      }
      
      // Create full 360Â° angle array
      const fullAngles = [];
      const fullLabels = [];
      
      // Add angles from 0Â° to 180Â° (port side)
      for (let i = 0; i <= 180; i += 15) {
        fullAngles.push(i);
        fullLabels.push(`${i}Â°`);
      }
      
      // Add angles from 195Â° to 345Â° (starboard side)
      for (let i = 195; i <= 345; i += 15) {
        fullAngles.push(i);
        fullLabels.push(`${i}Â°`);
      }
      
      // Create datasets for each wind speed
      const polarDatasets = [];
      const windSpeeds = [4, 6, 8, 10, 12, 14, 16, 20, 24];
      
      windSpeeds.forEach((tws, index) => {
        const speeds = fullAngles.map(angle => {
          // For angles > 180Â°, use the mirror angle (360Â° - angle)
          const lookupAngle = angle > 180 ? 360 - angle : angle;
          
          // Find closest angle in polar data
          let closestAngle = polarData[0];
          let minDiff = Math.abs(lookupAngle - polarData[0].twa);
          
          for (const point of polarData) {
            const diff = Math.abs(lookupAngle - point.twa);
            if (diff < minDiff) {
              minDiff = diff;
              closestAngle = point;
            }
          }
          
          return closestAngle.speeds[index] || 0;
        });
        
        const validSpeeds = speeds.filter(speed => speed > 0);
        if (validSpeeds.length > 0) {
          // Reverse the color order: red for max wind, blue for min wind
          const reversedIndex = windSpeeds.length - 1 - index;
          const hue = reversedIndex * 30; // 0 = red, 30 = orange, 60 = yellow, 120 = green, 180 = cyan, 240 = blue
          
          polarDatasets.push({
            label: `${tws} kts`,
            data: speeds,
            borderColor: `hsl(${hue}, 70%, 50%)`,
            backgroundColor: `hsla(${hue}, 70%, 50%, 0.1)`,
            borderWidth: 2,
            fill: false,
            tension: 0.4,
            order: 1 // Higher order values are drawn first (behind)
          });
        }
      });
      
      // Add current position as a single point
      // Normalize TWA to 0-360 range
      let normalizedTWA = currentTWA;
      while (normalizedTWA < 0) normalizedTWA += 360;
      while (normalizedTWA >= 360) normalizedTWA -= 360;
      
      // Find the closest angle in our chart's angle array
      const closestAngleIndex = fullAngles.reduce((closest, angle, index) => {
        return Math.abs(angle - normalizedTWA) < Math.abs(fullAngles[closest] - normalizedTWA) ? index : closest;
      }, 0);
      
      // Create a dataset with just the single point
      const currentData = new Array(fullAngles.length).fill(null);
      currentData[closestAngleIndex] = currentSpeed;
      
      console.log('Current position calculation:', {
        currentTWA,
        normalizedTWA,
        currentSpeed,
        closestAngleIndex,
        closestAngle: fullAngles[closestAngleIndex],
        fullAngles: fullAngles
      });
      
      console.log('Adding Current dataset:', {
        label: 'Current',
        data: currentData,
        closestAngleIndex,
        currentSpeed,
        nonZeroValues: currentData.filter(d => d > 0),
        nonZeroIndices: currentData.map((d, i) => d > 0 ? i : -1).filter(i => i !== -1)
      });
      
      // Add current position last so it appears on top
      polarDatasets.push({
        label: 'Current',
        data: currentData,
        borderColor: '#000000',
        backgroundColor: '#000000',
        borderWidth: 0, // No line
        pointRadius: 12,
        pointHoverRadius: 16,
        fill: false,
        tension: 0,
        showLine: false, // Don't draw lines between points
        order: -1 // Lower order values are drawn last (on top)
      });
      
      console.log('Total datasets:', polarDatasets.length);
      console.log('All datasets:', polarDatasets.map(ds => ({ label: ds.label, dataPoints: ds.data.filter(d => d > 0).length })));
      
      // Determine start and end angles based on focus side
      let startAngle, endAngle;
      if (focusSide === 'port') {
        startAngle = 180;
        endAngle = 0;
      } else {
        startAngle = 0;
        endAngle = 180;
      }
      
      polarChartInstance = new Chart(ctx, {
        type: 'radar',
        data: {
          labels: fullLabels,
          datasets: polarDatasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            tooltip: {
              callbacks: {
                title: ctx => `TWA: ${ctx[0].label}`,
                label: ctx => `${ctx.dataset.label}: ${ctx[0].parsed.r.toFixed(1)} kts`
              }
            },
            legend: {
              position: 'top',
              labels: { usePointStyle: true }
            }
          },
          scales: {
            r: {
              beginAtZero: true,
              title: { display: true, text: 'Boat Speed (kts)' },
              ticks: {
                stepSize: 2
              },
              pointLabels: {
                callback: function(value, index) {
                  return value;
                }
              },
              startAngle: startAngle,
              min: 0
            }
          }
        }
      });
      
      isDrawingPolarChart = false;
      console.log('Chart drawing completed');
    }



    async function loadWindForecast() {
      try {
        if (!lat || !lon) {
          document.getElementById('wind-forecast-grid').innerHTML = `
            <div class="wind-forecast-item">
              <div class="wind-time">Waiting</div>
              <div class="wind-speed">For GPS</div>
              <div class="wind-direction">Position</div>
            </div>
          `;
          return;
        }
        
        const selectedModel = document.getElementById('forecast-model').value;
        let response;
        
        // Select API based on chosen model
        switch(selectedModel) {
          case 'ecmwf':
            // ECMWF via OpenMeteo (free tier, global)
            response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=wind_speed_10m,wind_direction_10m&timezone=auto`);
            break;
          default:
            // Default to wttr.in (global)
            response = await fetch(`https://wttr.in/?format=j1&lat=${lat}&lon=${lon}`);
            break;
        }
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        let forecastHTML = '';
        const windForecastGrid = document.getElementById('wind-forecast-grid');
        
        // Parse data based on selected model
        if (selectedModel === 'wttr' && data && data.weather && data.weather[0] && data.weather[0].hourly) {
          // wttr.in format
          const timeIntervals = [3, 6, 9, 12];
          const usedIndices = new Set();
          
          timeIntervals.forEach(hours => {
            const targetTime = new Date();
            targetTime.setHours(targetTime.getHours() + hours);
            
            let closestForecast = null;
            let closestIndex = -1;
            let minDiff = Infinity;
            
            data.weather[0].hourly.forEach((forecast, index) => {
              if (usedIndices.has(index)) return;
              
              const forecastTime = new Date(forecast.time);
              const diff = Math.abs(forecastTime - targetTime);
              if (diff < minDiff) {
                minDiff = diff;
                closestForecast = forecast;
                closestIndex = index;
              }
            });
            
            if (closestForecast && closestForecast.windspeedKmph) {
              usedIndices.add(closestIndex);
              const windSpeedKmph = parseInt(closestForecast.windspeedKmph);
              const windSpeedKts = (windSpeedKmph * 0.539957).toFixed(1);
              const windDeg = parseInt(closestForecast.winddirDegree);
              const windDirection = getWindDirection(windDeg);
              
              const targetTime = new Date();
              targetTime.setHours(targetTime.getHours() + hours);
              const timeStr = targetTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
              
              const speedKts = parseFloat(windSpeedKts);
              let windColor = '';
              if (speedKts < 10) {
                windColor = 'background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);';
              } else if (speedKts >= 10 && speedKts < 15) {
                windColor = 'background: linear-gradient(135deg, #00b894 0%, #00a085 100%);';
              } else if (speedKts >= 15 && speedKts < 20) {
                windColor = 'background: linear-gradient(135deg, #fdcb6e 0%, #e17055 100%);';
              } else if (speedKts >= 20 && speedKts < 25) {
                windColor = 'background: linear-gradient(135deg, #e17055 0%, #d63031 100%);';
              } else {
                windColor = 'background: linear-gradient(135deg, #6c5ce7 0%, #a29bfe 100%);';
              }
              
              forecastHTML += `
                <div class="wind-forecast-item" style="${windColor}">
                  <div class="wind-time">+${hours}h (${timeStr})</div>
                  <div class="wind-speed">${windSpeedKts} kts</div>
                  <div class="wind-direction">${windDirection} (${windDeg}Â°)</div>
                </div>
              `;
            }
          });
        } else if (selectedModel === 'ecmwf' && data && data.hourly) {
          // ECMWF format
          const timeIntervals = [3, 6, 9, 12];
          const usedIndices = new Set();
          
          timeIntervals.forEach(hours => {
            const targetTime = new Date();
            targetTime.setHours(targetTime.getHours() + hours);
            
            let closestIndex = -1;
            let minDiff = Infinity;
            
            data.hourly.time.forEach((timeStr, index) => {
              if (usedIndices.has(index)) return;
              
              const forecastTime = new Date(timeStr);
              const diff = Math.abs(forecastTime - targetTime);
              if (diff < minDiff) {
                minDiff = diff;
                closestIndex = index;
              }
            });
            
            if (closestIndex >= 0) {
              usedIndices.add(closestIndex);
              const windSpeedMs = data.hourly.wind_speed_10m[closestIndex];
              const windSpeedKts = (windSpeedMs * 1.94384).toFixed(1); // m/s to knots
              const windDeg = data.hourly.wind_direction_10m[closestIndex];
              const windDirection = getWindDirection(windDeg);
              
              const targetTime = new Date();
              targetTime.setHours(targetTime.getHours() + hours);
              const timeStr = targetTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
              
              const speedKts = parseFloat(windSpeedKts);
              let windColor = '';
              if (speedKts < 10) {
                windColor = 'background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);';
              } else if (speedKts >= 10 && speedKts < 15) {
                windColor = 'background: linear-gradient(135deg, #00b894 0%, #00a085 100%);';
              } else if (speedKts >= 15 && speedKts < 20) {
                windColor = 'background: linear-gradient(135deg, #fdcb6e 0%, #e17055 100%);';
              } else if (speedKts >= 20 && speedKts < 25) {
                windColor = 'background: linear-gradient(135deg, #e17055 0%, #d63031 100%);';
              } else {
                windColor = 'background: linear-gradient(135deg, #6c5ce7 0%, #a29bfe 100%);';
              }
              
              forecastHTML += `
                <div class="wind-forecast-item" style="${windColor}">
                  <div class="wind-time">+${hours}h (${timeStr})</div>
                  <div class="wind-speed">${windSpeedKts} kts</div>
                  <div class="wind-direction">${windDirection} (${windDeg}Â°)</div>
                </div>
              `;
            }
          });

        } else {
          // Fallback for other models or errors
          forecastHTML = `
            <div class="wind-forecast-item">
              <div class="wind-time">Model</div>
              <div class="wind-speed">Not</div>
              <div class="wind-direction">Available</div>
            </div>
          `;
        }
        
        if (forecastHTML) {
          windForecastGrid.innerHTML = forecastHTML;
        } else {
          throw new Error('No forecast data available for this location');
        }
      } catch (error) {
        console.error('Wind forecast fetch error:', error);
        document.getElementById('wind-forecast-grid').innerHTML = `
          <div class="wind-forecast-item" style="background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);">
            <div class="wind-time">Error</div>
            <div class="wind-speed">${error.message}</div>
            <div class="wind-direction">Try another model</div>
          </div>
        `;
      }
    }
    
    function getWindDirection(degrees) {
      const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
      const index = Math.round(degrees / 22.5) % 16;
      return directions[index];
    }
    
    function connectSignalKWebSocket() {
      try {
        // SignalK WebSocket endpoint
        signalKWebSocket = new WebSocket('wss://192.168.8.50:3000/signalk/v1/stream');
        
        signalKWebSocket.onopen = function() {
          console.log('SignalK WebSocket connected');
          
          // Update status to show streaming
          const statusElement = document.getElementById('dataStatus');
          statusElement.textContent = 'ðŸ“¡ Streaming Data (Real-time)';
          statusElement.style.color = '#27ae60';
          
          // Subscribe to all updates
          signalKWebSocket.send(JSON.stringify({
            context: 'vessels.self',
            subscribe: [{
              path: '*',
              policy: 'instant'
            }]
          }));
        };
        
        signalKWebSocket.onmessage = function(event) {
          try {
            const update = JSON.parse(event.data);
            if (update.updates) {
              // Process real-time updates
              update.updates.forEach(updateData => {
                if (updateData.values) {
                  updateData.values.forEach(value => {
                    // Update the global data objects
                    updateSignalKData(value.path, value.value);
                  });
                }
              });
              // Refresh the display with new data
              updateDisplay();
            }
          } catch (error) {
            console.error('Error parsing WebSocket message:', error);
          }
        };
        
        signalKWebSocket.onerror = function(error) {
          console.error('SignalK WebSocket error:', error);
        };
        
        signalKWebSocket.onclose = function() {
          console.log('SignalK WebSocket disconnected');
          // Try to reconnect after 5 seconds
          setTimeout(connectSignalKWebSocket, 5000);
        };
      } catch (error) {
        console.error('Failed to connect to SignalK WebSocket:', error);
      }
    }
    
    function updateSignalKData(path, value) {
      // Update the global data objects based on SignalK path
      const pathParts = path.split('.');
      let current = window.signalKData || {};
      
      for (let i = 0; i < pathParts.length - 1; i++) {
        if (!current[pathParts[i]]) {
          current[pathParts[i]] = {};
        }
        current = current[pathParts[i]];
      }
      
      current[pathParts[pathParts.length - 1]] = value;
      window.signalKData = window.signalKData || {};
      
      // Update specific global variables
      if (path.startsWith('navigation.')) {
        currentNav = window.signalKData.navigation || {};
      } else if (path.startsWith('environment.')) {
        currentEnv = window.signalKData.environment || {};
      }
    }
    
    function updateDisplay() {
      // Update the dashboard display with current data
      if (window.signalKData) {
        const data = window.signalKData;
        const nav = data.navigation || {};
        const elec = data.electrical || {};
        const env = data.environment || {};
        
        // Update timestamp for streaming data
        const timeElement = document.getElementById('updateTime');
        const now = new Date();
        timeElement.textContent = `Last Updated: ${now.toLocaleString()}`;
        
        // Keep streaming status green
        const banner = document.getElementById('updateBanner');
        banner.style.background = '#dff0d8';
        banner.style.color = '#2c3e50';
        
        // Update data grid
        updateDataGrid(nav, elec, env, data);
        
        // Update polar performance
        updatePolarPerformance();
        
        // Update map location if coordinates available
        if (nav.position?.value?.latitude && nav.position?.value?.longitude) {
          updateMapLocation(nav.position.value.latitude, nav.position.value.longitude);
        }
      }
    }
    
    function updateDataGrid(nav, elec, env, data) {
      const lat = nav.position?.value?.latitude;
      const lon = nav.position?.value?.longitude;
      
      document.getElementById('data-grid').innerHTML = `
        <div class="info-item"><div class="label">Latitude</div><div class="value">${lat?.toFixed(6) ?? 'N/A'}</div></div>
        <div class="info-item"><div class="label">Longitude</div><div class="value">${lon?.toFixed(6) ?? 'N/A'}</div></div>
        <div class="info-item"><div class="label">COG</div><div class="value">${nav.courseOverGroundTrue?.value ? (nav.courseOverGroundTrue.value * 180 / Math.PI).toFixed(0) + 'Â°' : 'N/A'}</div></div>
        <div class="info-item"><div class="label">SOG</div><div class="value">${nav.speedOverGround?.value ? (nav.speedOverGround.value * 1.94384).toFixed(1) + ' kts' : 'N/A'}</div></div>
        <div class="info-item"><div class="label">STW</div><div class="value">${nav.speedThroughWater?.value ? (nav.speedThroughWater.value * 1.94384).toFixed(1) + ' kts' : 'N/A'}</div></div>
        <div class="info-item"><div class="label">Trip</div><div class="value">${nav.trip?.log?.value ? (nav.trip.log.value / 1852).toFixed(1) + ' nm' : 'N/A'}</div></div>
        <div class="info-item"><div class="label">Log</div><div class="value">${nav.log?.value ? (nav.log.value / 1852).toFixed(1) + ' nm' : 'N/A'}</div></div>
        <div class="info-item"><div class="label">Water Temp</div><div class="value">${env.water?.temperature?.value ? ((env.water.temperature.value - 273.15) * 9/5 + 32).toFixed(1) + 'Â°F' : 'N/A'}</div></div>
        <div class="info-item"><div class="label">Wind Speed</div><div class="value">${env.wind?.speedTrue?.value ? (env.wind.speedTrue.value * 1.94384).toFixed(1) + ' kts' : 'N/A'}</div></div>
        <div class="info-item"><div class="label">Wind Dir</div><div class="value">${env.wind?.angleTrueWater?.value ? (env.wind.angleTrueWater.value * 180 / Math.PI).toFixed(0) + 'Â°' : 'N/A'}</div></div>
        <div class="info-item"><div class="label">Battery Voltage</div><div class="value">${elec.batteries?.house?.voltage?.value?.toFixed(2) ?? 'N/A'} V</div></div>
        <div class="info-item"><div class="label">Battery Current</div><div class="value">${elec.batteries?.house?.current?.value?.toFixed(1) ?? 'N/A'} A</div></div>
        <div class="info-item"><div class="label">Battery Power</div><div class="value">${elec.batteries?.house?.power?.value?.toFixed(1) ?? 'N/A'} W</div></div>
        <div class="info-item"><div class="label">SOC</div><div class="value">${elec.batteries?.house?.capacity?.stateOfCharge?.value ? (elec.batteries.house.capacity.stateOfCharge.value * 100).toFixed(0) + '%' : 'N/A'}</div></div>
        <div class="info-item"><div class="label">Battery Time Remaining</div><div class="value">${elec.batteries?.house?.capacity?.timeRemaining?.value ? (elec.batteries.house.capacity.timeRemaining.value / 3600).toFixed(1) + ' hrs' : 'N/A'}</div></div>
        <div class="info-item"><div class="label">Anchor Distance</div><div class="value" style="color: ${nav.anchor?.currentRadius?.value && nav.anchor?.maxRadius?.value ? (nav.anchor.currentRadius.value > nav.anchor.maxRadius.value ? '#e74c3c' : '#27ae60') : '#2c3e50'}">${nav.anchor?.currentRadius?.value ? (nav.anchor.currentRadius.value * 3.28084).toFixed(1) + ' ft' : 'N/A'}</div></div>
        <div class="info-item"><div class="label">Anchor Bearing</div><div class="value">${nav.anchor?.bearingTrue?.value ? (nav.anchor.bearingTrue.value * 180 / Math.PI).toFixed(0) + 'Â°' : 'N/A'}</div></div>
        <div class="info-item"><div class="label">Vessel Length</div><div class="value">${data.design?.length?.value?.overall ? (data.design.length.value.overall * 3.28084).toFixed(1) + ' ft' : 'N/A'}</div></div>
        <div class="info-item"><div class="label">Vessel Beam</div><div class="value">${data.design?.beam?.value ? (data.design.beam.value * 3.28084).toFixed(1) + ' ft' : 'N/A'}</div></div>
        <div class="info-item"><div class="label">Vessel Draft</div><div class="value">${data.design?.draft?.value?.maximum ? (data.design.draft.value.maximum * 3.28084).toFixed(1) + ' ft' : 'N/A'}</div></div>
        <div class="info-item"><div class="label">MMSI</div><div class="value">338543654</div></div>
        <div class="info-item"><div class="label">USCG #</div><div class="value">1024168</div></div>
        <div class="info-item"><div class="label">Rudder Angle</div><div class="value">${data.steering?.rudderAngle?.value ? (data.steering.rudderAngle.value * 180 / Math.PI).toFixed(1) + 'Â°' : 'N/A'}</div></div>
        <div class="info-item"><div class="label">Distance to WP</div><div class="value">${data.navigation?.courseRhumbline?.nextPoint?.distance?.value ? (data.navigation.courseRhumbline.nextPoint.distance.value / 1852).toFixed(1) + ' nm' : 'N/A'}</div></div>
        <div class="info-item"><div class="label">Course Bearing</div><div class="value">${data.navigation?.courseRhumbline?.bearingTrackTrue?.value ? (data.navigation.courseRhumbline.bearingTrackTrue.value * 180 / Math.PI).toFixed(0) + 'Â°' : 'N/A'}</div></div>
        <div class="info-item"><div class="label">Bearing to Dest</div><div class="value">${data.navigation?.courseRhumbline?.bearingToDestinationTrue?.value ? (data.navigation.courseRhumbline.bearingToDestinationTrue.value * 180 / Math.PI).toFixed(0) + 'Â°' : 'N/A'}</div></div>
        <div class="info-item"><div class="label">Cross Track Error</div><div class="value">${data.navigation?.courseRhumbline?.crossTrackError?.value ? data.navigation.courseRhumbline.crossTrackError.value.toFixed(1) + ' m' : 'N/A'}</div></div>
        <div class="info-item"><div class="label">Apparent Wind Angle</div><div class="value">${data.environment?.wind?.angleApparent?.value ? (data.environment.wind.angleApparent.value * 180 / Math.PI).toFixed(0) + 'Â°' : 'N/A'}</div></div>
        <div class="info-item"><div class="label">Apparent Wind Speed</div><div class="value">${data.environment?.wind?.speedApparent?.value ? (data.environment.wind.speedApparent.value * 1.94384).toFixed(1) + ' kts' : 'N/A'}</div></div>
      `;
    }

    document.addEventListener("DOMContentLoaded", function() {
      loadPolarData();
      loadData();
      
      // Try to connect to SignalK WebSocket for real-time updates
      connectSignalKWebSocket();
      
      // Add event listener for forecast model dropdown
      document.getElementById('forecast-model').addEventListener('change', function() {
        if (lat && lon) {
          loadWindForecast();
        }
      });
      
      // Update wind forecast every hour
      setInterval(() => {
        if (lat && lon) {
          loadWindForecast();
        }
      }, 60 * 60 * 1000);
    });
  </script>
  <div class="footer">
    Created by <a href="https://zackphillips.com" target="_blank">Zack Phillips</a>
  </div>
</body>
</html>

